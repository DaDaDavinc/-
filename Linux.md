<!-- TOC -->

- [进程与线程](#进程与线程)
    - [多进程和多线程的区别](#多进程和多线程的区别)
    - [进程与线程有什么区别？](#进程与线程有什么区别)
    - [线程具有哪些优势？](#线程具有哪些优势)
    - [有了进程为什么还需要线程？](#有了进程为什么还需要线程)
    - [线程、进程的基本状态](#线程进程的基本状态)
    - [多线程有哪些实现方式？](#多线程有哪些实现方式)
    - [Linux中的线程和进程相关的函数](#linux中的线程和进程相关的函数)
    - [竞争条件](#竞争条件)
    - [临界区](#临界区)
    - [线程同步和互斥实现方法](#线程同步和互斥实现方法)
    - [同步、互斥区别](#同步互斥区别)
    - [加锁](#加锁)
- [内存池](#内存池)
- [进程调度](#进程调度)
- [死锁](#死锁)
    - [死锁产生的条件(4个)](#死锁产生的条件4个)
    - [如何避免死锁](#如何避免死锁)
- [操作命令](#操作命令)
    - [grep](#grep)
    - [awk](#awk)
    - [sed](#sed)
    - [find](#find)
    - [netstat](#netstat)
    - [tcpdump](#tcpdump)
    - [ipcs](#ipcs)
    - [ipcrm](#ipcrm)
    - [free](#free)
    - [top](#top)
    - [df](#df)
    - [du](#du)
    - [fdisk](#fdisk)
    - [ps](#ps)
- [IO模型](#io模型)
    - [阻塞I/O](#阻塞io)
    - [非阻塞I/O](#非阻塞io)
    - [I/O复用模型](#io复用模型)
    - [信号驱动I/O模型](#信号驱动io模型)
    - [异步I/O](#异步io)
    - [各种 IO 模型的比较](#各种-io-模型的比较)
    - [多路复用I/O之select、poll、epoll](#多路复用io之selectpollepoll)
        - [select](#select)
        - [poll](#poll)
        - [epoll(非阻塞IO库)](#epoll非阻塞io库)
- [线程池](#线程池)
- [进程间通讯方式](#进程间通讯方式)
- [Linux API](#linux-api)
    - [fork与vfork区别](#fork与vfork区别)
    - [exit()与_exit()区别](#exit与_exit区别)
    - [Linux如何避免内存碎片](#linux如何避免内存碎片)
    - [共享内存实现原理](#共享内存实现原理)
    - [ETF是什么？](#etf是什么)
    - [同步方法](#同步方法)
    - [系统调用与库函数](#系统调用与库函数)
- [Makefile 编写](#makefile-编写)
- [GDB 相关](#gdb-相关)
- [如何定位内存泄露](#如何定位内存泄露)
    - [Linux 检测内存泄露](#linux-检测内存泄露)
    - [静态分析(文本检测)](#静态分析文本检测)
    - [动态检测(运行阶段)](#动态检测运行阶段)
- [动态链接和静态链接的区别](#动态链接和静态链接的区别)
- [32位系统一个进程最多多少堆内存](#32位系统一个进程最多多少堆内存)
- [如何实现守护进程Daemon？](#如何实现守护进程daemon)
- [Linux内存管理机制](#linux内存管理机制)
- [Linux任务调度机制](#linux任务调度机制)
    - [不可抢占型](#不可抢占型)
    - [可抢占型](#可抢占型)
    - [任务调度](#任务调度)
    - [调度算法](#调度算法)
- [系统如何将一个信号signal通知到进程](#系统如何将一个信号signal通知到进程)
- [宏替换](#宏替换)

<!-- /TOC -->
## 进程与线程
### 多进程和多线程的区别
[多进程和多线程的区别](https://blog.csdn.net/linraise/article/details/12979473)
* 什么东西是一个线程私有的？
1. 寄存器(寄存器组的值)
2. 线程ID
3. 线程的堆栈
4. 错误返回码

### 进程与线程有什么区别？
1. 概念不同：进程是资源分配的基本单位；线程是cpu调度，是程序执行的最小单位。
2. 进程有独立的地址空间，而同一进程中的线程共享该进程的地址空间
3. 通信方式不同

进程间通信(IPC)方式|线程间通信
--|--
管道、信号、消息队列、共享内存、信号量、信号量、套接字|锁、信号量、信号
4. 线程无法独立运行，要依赖程序，由程序提供的多个线程并发进行。

### 线程具有哪些优势？
* 进程需要独立的地址空间，线程之间共享内存，资源消耗少；所以对于大并发，只有在多线程加上IO复用才能适应
* 进程之间相互独立，但进程之间的切换和通信代价大
* 一个线程死掉，会影响整个进程，但线程间共享资源，通信方便

### 有了进程为什么还需要线程？
* 一个任务可以细分成多个小任务，他们是同一个对象在操作
* 线程不用像进程一样维护那么多信息，因此线程的创建和销毁速度比较快；且拥有同一个地址空间，访问方便
* 任务有CPU密集和IO等待的过程，利用线程可以最大化利用CPU

### 线程、进程的基本状态
* 三种基本状态   
运行、就绪、阻塞
* 四种状态转换   
运行->阻塞    就绪->运行   运行->就绪   阻塞->就绪

### 多线程有哪些实现方式？
1. 调用系统接口
2. 第三方线程库如 Boost / MFC
3. C/C++库函数

### Linux中的线程和进程相关的函数
功能|线程相关API|进程相关API
--|--|--
创建|pthread_create|fork
获取退出状态|pthread_exit|exit
等待|pthread_join|waitpid
获得自身ID|pthread_self|getpid

### 竞争条件
也叫竞态条件，race condition，多个进程(或线程)共享内存(或文件)时就是出项竞争条件，竞争条件的意思是说两个或者多个进程读写某些共享数据，而`最后的结果`取决于进程运行的精确时序。

![](http://upload-images.jianshu.io/upload_images/2450319-1d428c7cc3655021.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
上图可以看出Thread B是最后一个线程，所以Integer结果在执行Thread A后没有改变，直到执行Thread B

![](http://www.ntu.edu.sg/home/ehchua/programming/java/images/Multithread.gif)

### 临界区
我们可以简单地把程序代码分成两部分：不会导致竞争条件的程序片段和会导致竞争条件的程序片段。`会导致竞争条件的程序片段就叫做临界区。`避免竞争条件只需要阻止多个进程同时读写共享的数据就可以了，也就是`保证同时只有一个进程处于临界区内`。

![](http://legendtkl.com/img/uploads/2016/critical_zone.png)


### 线程同步和互斥实现方法
* 信号量  

对应一个down和up操作(原子操作)，down--，同时引起up++，直到down==0，进入sleep状态
* 互斥量  

互斥量是信号量的一种特例，只有两个状态：1加锁，0解锁
* 关键区域    

和互斥量类似，不同的是关键区域有忙等待状态，而互斥量如果不能解锁会自动让出CPU
### 同步、互斥区别
* 互斥  
是指某一资源同时只允许`一个访问者`对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是`无序`的。如火车票售票是互斥的。

* 同步  
是指`在互斥的基础上`，通过其它机制实现访问者对资源的`有序访问`。

### 加锁  
**互斥锁**:只有取得互斥锁的进程才能进入临界区，无论读写  

**读写锁**:要根据进程进入临界区的具体行为（读，写）来决定锁的占用情况。这样锁的状态就有三种了：读模式加锁、写模式加锁、无锁。
1. 读模式锁:读进程可以进入,写进程不可以进入
2. 写模式锁:读/写进程都不可以进入
3. 无锁:读/写进程都可以进入

**自旋锁**：自旋锁是指在进程试图取得锁失败的时候选择`忙等待`而不是阻塞自己，可以减少上下文切换时间。但是有个隐患：单处理器可能出现CPU空转。   
**屏障**

## 内存池
* 原理  

先调用**malloc**函数申请一大块内存，然后维护一个空闲链表(该链表是一个个小的空闲内存片)，每当需要内存时就从空闲链表上选取相应大小的内存使用。如果空闲链表为空，就从之前分配的大块内存去取几个插入到空闲链表上。如果分配的大块内存也用光了，就继续用malloc申请一大块。

* 作用

内存池（memory pool)是代替直接调用malloc/free、new/delete进行内存管理的常用方法，当我们申请内存空间时，首先到我们的内存池中查找合适的内存块，而不是直接向操作系统申请

* 优势
1. 比malloc/free进行内存申请/释放的方式快
2. 减少内存碎片，
3. 避免内存泄露

## 进程调度
* Linux进程分为实时进程、非实时进程(交互式和批处理进程)
* 优先级分为静态优先级、动态优先级，优先级的范围为 -20~19，权限依次减小。
* 优先级调度策略

Linux主要有三种调度策略：
1. **SCHED_OTHER** 分时调度策略
2. **SCHED_FIFO**  实时调度策略，先到先服务
3. **SCHED_RR**    实时调度策略，时间片轮转
* 交互进程(非实时)通过平均睡眠时间而被奖励

## 死锁
概念：多个线程同时被阻塞，且一直处于阻塞状态，称为死锁。     
分类：
1. 资源死锁：多个线程或进程同时获取资源时发生     
2. 通信死锁：由于网络延时或丢包，导致两个进程都在等待对方的数据。可以通过超时重发机制解决。

### 死锁产生的条件(4个)
1. 互斥条件：一个资源不能同时被两个或两个以上的进程访问
2. 占有和等待条件:一个资源已经被另一个进程占用，那么该进程只能等待。
3. 不可抢占:已经分配给某个进程的资源，不能通过调度的方式抢占该资源，只能等待占有方让出锁
4. 环路等待条件:多个进程和资源组成环路


p1和p2表示两个进程，s1和s2表示资源。有向图成环，发生死锁。

### 如何避免死锁
1. 忽略死锁问题(避免因小失大)
2. 检测死锁并恢复(抢占式恢复、回滚恢复、杀死部分进程)
3. 仔细分配资源，从一开始就尽量避免死锁
4. 破坏死锁产生的条件：破坏互斥条件、占有和等待条件、不可抢占条件、避免成环

## 操作命令
文本处理三剑客：grep/awk/sed

### grep
全局搜索正则表达式，强大的文本搜索工具。
```bash
# 在多个文本中查找匹配项
grep "match_pattern" file1 (file2 file3...) 
# 输出除了匹配项之外的所有行
grep -v "match" file   
# 统计匹配项的行数
grep -c "match" file   
# 输出匹配项的后三行
grep "match" -A 3 file 
# 递归搜索当前目录匹配项
grep "match" . -r -n    
```
### awk
主要用于文本内容的分析处理。如果对处理的数据需要生成报告之类的信息，或者处理的数据是按列进行处理的，最好使用awk。
```baah
# 以：分割file的每一行并打印第一行
awk -F ':' '{print $1}' file
```
### sed
sed命令主要用于文本内容的编辑
```bash
# 在文本末尾追加一行内容
sed '$a hello world' file
# 在第一行插入文本
sed '1i hello world' file
# 同时追加和插入
sed '-e $a hello -e 1i hello' file
# 搜索、替换所有匹配项
sed 's/oldString/newString/g' file
```
### find
查找文件。配合xargs使用可以防止参数长度溢出。
```bash
# 查找当前目录下的所有文件并匹配指定字符串
find . | xargs grep -ri "match_pattern"
# 查找当前目录下的.cpp文件并匹配字符串
find . | -name "*.cpp" xargs grep -ri "match"
```
### netstat
打印Linux网络系统的状态信息，可以知道整个Linux系统的网络情况
```bash
# 查看哪些IP连接本机
netstat -an
# 统计80端口连接数
netstat -nat | grep -i "80" | wc -l
# 统计httpd协议的连接数
ps -ef | grep httpd | wc -l
# 统计已经连上的，状态为established
netstat -na | grep ESTABLISHED |wc -l
# 列出所有TCP相关的端口
netstat -at 
# udp
netstat -au
# 处于监听状态的端口
netstat -l / -lt / -lu / -lx
# 列出每个协议的统计信息
netstat -s / -st / -su
# 持续输出netstat信息
netstat -c 
```
### tcpdump
抓包。可以打印所有经过网络接口的数据包的头信息，-w选项可以保存这些头信息
```bash
# 监听第一个网络接口上所有流过的数据包
tcpdump
# 监听指定接口
tcpdump -i lo
# 截获主机发送的所有数据包
tcpdump -i eth0 src host hostname
# 截获发送给主机的所有数据包
tcpdump -i eth0 dst host hostname
```
### ipcs 
IPC(进程间通信)，用于报告Linux中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。
```bash
# 显示全部可显示的信息
ipcs -a 
# 显示消息队列
ipcs -q
# 显示信号量
ipcs -s
# 显示共享内存
ipcs -m
```
### ipcrm
ipcrm命令用来删除一个或更多的消息队列、信号量集或者共享内存标识。
```bash
# 删除和 SharedMemoryID 18602 相关的共享内存段
ipcrm -m 18602
```
### free
free命令可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区
```bash
# 以MB为单位显示内存使用情况 (-k -b )
free -m
```
### top 
top命令可以实时动态地查看系统的整体运行情况

### df 
df命令用于显示`磁盘分区上的可使用的磁盘空间`。默认显示单位为KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。
```bash
# kb
df 
# kb以上的单位，可读性高
df -h 
# 全部文件系统
df -a 
```
### du 
du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对`文件和目录磁盘使用的空间`的查看，还是和df命令有一些区别的。
```bash
# 查看指定目录的大小
du dir
# 查看指定文件的大小
du file
# 只显示总和的大小
du -s test
```
### fdisk 
fdisk命令用于观察硬盘实体使用情况，也可对硬盘分区。   
设备文件：指定要进行分区或者显示分区的硬盘设备文件。
```bash
# fdisk /dev/sdb
```
### ps
查看进程
```bash
# 查看所有运行的进程
ps -aux | less
# 查看系统的每一个进程
ps -A 
ps -e 
```
## IO模型

### 阻塞I/O
最流行的 IO 操作是阻塞式 IO(Blocking IO). 以 UDP 数据报套接字为例, 下图是其阻塞 IO 的调用过程:

![](https://segmentfault.com/img/bVE1LM?w=695&h=381)

在上图中, 进程调用 recvfrom, 其系统调用直到数据报返回并且被复制到应用进程的缓冲区中 或者发送错误时才返回. 因此进程在调用 recvfrom 开始到它返回的整段时间内都是被阻塞的.
### 非阻塞I/O
进程把一个套接字设置为非阻塞是在通知内核: `当调用线程所请求的 IO 操作需要调用线程休眠来等待操作完成时, 此时不要将调用线程休眠, 而是返回一个错误.`

![](https://segmentfault.com/img/bVE1LQ?w=780&h=436)

如上图所示, 前三次调用 recvfrom 时, 没有数据可返回, 因此内核转而立即返回一个 EWOULDBLOCK 错误. 第四次调recvfrom 时, 内核已经将数据准备好了。`此时, recvfrom 会阻塞住, 等待内核将数据拷贝到应用进程的缓冲区中, 然后再返回.`(注意, 当有数据时, recvfrom 是阻塞的, 它会等待内核将数据复制到应用进程的缓冲区后, 才返回).

当一个应用进程像这样对一个非阻塞描述符循环调用 recvfrom 时, 我们称之为**轮询(polling)**. 应用进程持续轮询内核, 以查看某个操作是否完成, 这么做`会消耗大量的 CPU 时间`, 不过这种模型偶尔也会遇到, 通常是专门提供某一种功能的系统中才有.

### I/O复用模型
有了 IO 复用(IO multiplexing), 我们就可以调用 **select** 或 **poll**, 阻塞在这两个系统调用中的某一个之上, 而不是阻塞在真正的 IO 系统调用上. 例如:

![](https://segmentfault.com/img/bVE1LR?w=776&h=415)

如上图所示, 当调用了**select** 后, select 会阻塞住, 等待数据报套接字变为可读. 当 select 返回套接字可读这一条件时, 我们就可以调用 recvfrom 把所读取的数据报复制到应用进程缓冲区.

对比阻塞式 IO, IO 复用模型优势并不明显, 并且从使用方式来说,IO 复用模型还需要多调用一次 select, 因此从易用性上来说, 比阻塞式 IO 还略有不足. 不过 `select 的杀手锏在于它可以监听多个文件描述符, 大大减小了阻塞线程的个数.`
### 信号驱动I/O模型
![](https://segmentfault.com/img/bVE1LZ?w=816&h=428)

信号驱动模型如上图所示. 当文件描述符就绪时, 我们可以让内核以信号的方式通知我们.

我们首先需要开启套接字的信号驱动式 IO 功能, 并通过 sigaction 系统调用安装一个信号处理函数. sigaction 系统调用是异步的, 它会立即返回. 当有数据时, 内核会给此进程发送一个 SIGIO 信号, 进而我们的信号处理函数就会被执行, 我们就可以在这个函数中调用 recvfrom 读取数据.
### 异步I/O
异步 IO (asynchronous IO) 由 POSIX 规范定义, 在 POSIX 中定义了若干个异步 IO 的操作函数. 这个函数的工作原理是: 告知内核启动某个动作, 并让内核在整个操作(`包括将数据从内核复制到应用进程缓冲区`)完成后通知我们的应用进程.

异步 IO 模型和信号驱动的 IO 模型的主要区别在于: `信号驱动 IO 是由内核通知我们何时可以启动一个 IO 操作, 而异步 IO 模型是由内核通知我们 IO 操作何时完成.`

异步 IO 模型的操作过程如图所示:

![](https://segmentfault.com/img/bVE1L0?w=761&h=491)

当我们调用 aio_read 函数时(**POSIX 异步 IO 函数以 aio_或 lio_ 开头**), 给内核传递描述符, 缓冲区指针, 缓冲区大小(和 read 相同的三个参数) 和文件偏移(以 lseek 类似), 并告诉内核当整个操作完成时如何通知应用进程. 该系统调用立即返回, 而且在等待 IO 完成期间, 应用进程不被阻塞.

### 各种 IO 模型的比较
![](https://segmentfault.com/img/bVE1L1?w=944&h=512)

### 多路复用I/O之select、poll、epoll

#### select
```C
#include <sys/select.h>
#include <sys/time.h>
int select(int max_fd, fd_set *readset, fd_set *writeset, 
           fd_set *execptset, struct timeval* timeout);
           //fa_set 描述符集
```
* 优点   
基于select的I/O复用模型的是单进程执行，占用资源少，可以为多个客户端服务。
* 缺点   
但是select需要**轮询**每一个描述符`( O(N) )`，在高并发时仍然会存在效率问题，同时select能支持的最大连接数通常受限(1024)。
#### poll 
```C
int poll(struct pollfd *fds, unsigned int nfds, int timeout);
```
不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现
```C
struct pollfd {
    int fd;
    short events;   //要监视的事件
    short revents;  //发生的事件
};
```
* 和select比较
1. pollfd结构包含了要监视的event和发生的event，不再使用select`参数-值传递`的方式
2. pollfd没有最大数量限制（但是数量过大后性能也是会下降）
3. 和select函数一样，poll返回后，需要**轮询**pollfd来获取就绪的描述符`( O(N) )`。
4. select和poll都需要在返回后，`通过遍历文件描述符来获取已经就绪的socket`，造成效率降低。

#### epoll(非阻塞IO库)

1. epoll是select和poll的增强版，基于事件驱动，更加灵活，没有文件描述符的限制。
2. epoll使用一个描述符管理多个文件描述符，将用户关心的fd存放在内核的一个事件表中，则在用户空间和内核空间只需拷贝一次(拷贝整个事件表)
* 优点
1. 没有最大并发连接的限制，能打开的fd上限远大于1024（1G的内存能监听约10万个端口）
2. 采用**回调**的方式，效率提升。`( O(1) )` 只有`活跃可用`的fd才会调用callback函数，也就是说 epoll 只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，epoll的效率就会远远高于select和poll。
3. 内存拷贝。使用`mmap()文件映射内存`来加速与内核空间的消息传递，减少复制开销。
* epoll对文件描述符fd的操作有两种：水平触发(LT)、边缘触发(ET)
* 水平触发

当epoll_wait检测到某个描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件。等下次再次调用epoll_wait时，会`再次通知`。(任性)

* 边缘触发

当epoll_wait检测到某个描述符事件就绪并通知应用程序时，应用程序如果没有立即执行，下次再次调用epoll_wait时，`不会再次通知`，除非有某个操作另事件由未就绪变为就绪状态，即存在这个边缘时，才能触发通知。

* `epoll`是Linux目前`大规模网络并发`程序开发的首选模型。在绝大多数情况下性能远超epll和select.
* 但是，`并发连接规模不大`的情况下，选择`多线程+阻塞IO`方式性能可能更好.

* 为什么使用IO多路复用，最主要的原因是什么？

高速处理大规模网络并发事件，解决IO阻塞的问题。采用了多路复用IO后，程序可以自由的进出程序进行除了IO操作外的工作，直到IO状态发生了改变并由多路复用IO发出通知，才发生相应的动作。
* [几种网络服务器模型](https://www.ibm.com/developerworks/cn/linux/l-cn-edntwk/index.html?ca=drs-)


## 线程池

`备胎池，多用于高并发情况。`一般的并发是新增一个连接就为新的连接开一个线程为其服务，但是开启线程和关闭线程都需要耗费一定的时间。因此，为了提高效率，`预先创建一定数量的线程，并让线程处于阻塞状态`，当新来了一个连接就从线程池中挑一个线程为其服务，服务完毕后线程也不关闭，重新放回池子。线程池就是这样采用一个`队列或其他容器`，维持一定数量线程。

## 进程间通讯方式

* 七种通信方式

方式|定义
--|--
(匿名)管道(pipe)|半双工,单向,只能在具有公共祖先的两个进程间使用
命名管道(FIFO)|半双工,允许无亲缘关系进程间的通信
信号量|信号量用于实现进程间的互斥与同步,而不是用于存储进程间通信数据
消息队列|消息的链表，有足够权限的进程可以向队列中添加消息或读取消息.克服了信号承载信息量少，管道智能承载无格式字节流以及缓冲区大小受限等问题
共享内存|映射一段能被其他进程所访问的内存，使多个进程可以访问同一块内存，是最快的IPC方式;与信号量结合使用，实现进程间的同步与互斥
信号(signal)|用于通知接收进程某个事件已经发生
套接字(socket)|可用于不同进程间通信IPC

* 共享映射文件 mmap

建立`进程空间到文件的映射`，在建立的时候并不直接将文件拷贝到物理内存，同样采用缺页终端。mmap映射一个`具体文件`可以实现任意进程间共享内存，映射一个`匿名文件`，可以实现父子进程间共享内存。

* 常见信号

信号|含义
--|--
SIGINT|程序终止信号
SIGKILL|立即结束程序的运行,不能被阻塞、处理和忽略，异常退出
SIGTERM|程序结束(terminate)信号,与SIGKILL不同的是该信号可以被阻塞和处理
SIGSEGV|试图访问未分配给自己的内存
SIGCHLD|子进程结束时, 父进程会收到这个信号
SIGALRM|时钟定时信号

## Linux API

### fork与vfork区别
* fork

1. fork是克隆了一个与父进程几乎原来一样，具有独立的内存资源，存放的数据和代码与父进程相差无几的子进程。二者进行的操作不会影响到彼此。
2. 在内核中，fork()-->clone()-->do_fork()-->copy_process(),copy_process()先拷贝task_struct结构体，再复制父进程的关于内存，数据等信息，拥有独立的内存。fork()采用`写实拷贝技术`，会复制父进程的页表，因此子进程和父进程的页表指向相同的页框。
3. 与exec()要配合使用，不然父子进程的行为一样，没有什么意义。使用exec可以执行其他的行为。但是会产生新的数据段和堆栈，影响效率。

* vfork
1. vfork创建子进程后，不同于fork复制页表，vfork直接共用父进程的页表，所以父子进程公用一块内存地址，甚至共享同一块堆栈。
2. vfork创建的子进程结束时必须执行_exit()或exec()，不能调用其他函数(包括exit())，不能执行任何数据修改(甚至不能return)
3. 父进程会一直阻塞，直到子进程调用`_exit() or execl()`。

* vfork这么危险，为什么还要用？

fork()搭配使用exec()时会产生新的数据段和堆栈，影响效率。而vfork()不会，效率比较高。

### exit()与_exit()区别
exit()清理后进入内核，_exit()直接陷入内核。exit()是对_exit()的封装，在调用_exit()前执行了清理工作。

![](http://img.my.csdn.net/uploads/201303/05/1362494099_4563.png)

从图中可以看出，_exit()直接调用系统调用exit，执行退出；而exit()在调用系统函数前执行了清除IO缓存等工作。

### Linux如何避免内存碎片

* **伙伴算法**，用于关于物理内存，避免内存碎片
* **高速缓存Slab层**，用于管理内核分配的内存，避免内存碎片

### 共享内存实现原理

[Linux虚拟地址空间分布](https://blog.csdn.net/zjy900507/article/details/80707783)
* C++进程内存地址分配

名称|存储内容
--|--
栈|局部变量、函数参数、返回地址等
堆|动态分配的内存
BSS段|未初始化或初值为0的全局变量和静态局部变量
数据段|已初始化且初值非0的全局变量或静态局部变量
代码段|可执行代码、字符串字面符、只读变量
栈从高地址到低地址分配，堆从低到高分配。

mmap内存文件映射|XSI机制的共享内存
--|--
通过映射文件到不同进程中，实现进程之间的通信|也是通过映射文件，但这个文件是一种特殊文件系统下的文件，不能read/write
可以匿名映射，但是只能作用于父子进程|不能匿名映射
可以指定何时写入磁盘|不能写入实际磁盘文件

在Linux中，每个进程都有属于自己的`进程控制块（PCB）`和`地址空间（Addr Space）`，并且都有一个与之对应的`页表`，负责将进程的虚拟地址与物理地址进行映射，通过`内存管理单元（MMU）`进行管理。两个不同的虚拟地址通过页表映射到物理空间的同一块区域，它们所指向的这块区域即共享内存。

![](https://www.1024do.com/wp-content/uploads/2017/05/gxnc1.png)
这块内存可以被两个Precess同时看到，要确保一个进程在写的时候不能被读，因此我们使用`信号量来实现同步与互斥`。

对于一个共享内存，实现采用的是`引用计数`的原理，当进程脱离共享存储区后，计数器会减一，挂架成功时，计数器会加一，只有当计数器变为零时，才能被删除。当进程终止的时候，它所附加的共享存储区都会自动脱离。

* 为什么共享内存是最快的IPC方式？

因为进程A往共享内存块写入数据(数据从A拷贝到内存块 +1 )，B从内存块读数据(数据从内存块拷贝到B +2)，`一共只需要两次拷贝`，所以速度快很多。

* 共享内存段被映射进进程空间之后，存在于进程空间的什么位置？共享内存段最大限制是多少？

```bash
sysctl kern.ipc.shmmax    //查看共享内存大小
kern.ipc.shmmax:33554432
```
共享内存位于数据段，最大限制为0x20000000字节

![](https://michaelyou.github.io/img/%E4%B8%80%E4%B8%AAlinux%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8%E6%98%A0%E5%83%8F.png)
程序内总是从虚拟地址0x08048000处开始。用户栈总是从虚拟地址0xbfffffff处开始，共享对象总是加载在`从虚拟地址0x40000000处开始`的区域内。

### ETF是什么？


### 同步方法
* 锁(互斥锁、读写锁、自旋锁)、信号量、屏障
* 互斥锁和自旋锁的区别

互斥锁得不到资源的情况下阻塞，不会占用CPU资源；而自旋锁得不到资源时，会不停的询问，消耗资源

* 死锁

### 系统调用与库函数

系统调用|库函数调用
--|--
操作系统内核提供|函数库或用户提供
运行于内核态|运行于用户态
需要从用户态切换到内核态，速度慢|不需要切换，速度快

* 库函数调用有什么作用？

减少系统调用的开销
* 库函数如何减少系统调用开销？

`缓冲区技术`。因为读写文件通常涉及大量的数据(这里的大量是对于底层驱动的系统调用所实现的数据操作单位而言的),使用库函数可以减少频繁的系统调用次数.

`缓冲区技术`：在用户空间和内核空间，对文件的操作都使用了缓冲区，当内核缓冲区写满或写结束之后，才将缓冲区内容写到对应的硬件媒介中，而不是每写一次操作一次硬件媒介。

* 系统调用有什么作用？

主要有三个作用？
1. 为应用程序提供了一组硬件层的抽象接口，用户可以直接通过这组接口访问系统资源，而不需要去了解系统底层。
2. 系统调用保证了系统的稳定和安全。可以基于权限对将要进行的访问进行裁决，防止用户层访问系统资源
3. 如果用户可以随意访问系统硬件资源而内核对此一无所知的话，将无法实现多任务和虚拟内存，(因为多任务即多进程，需要良好的内存资源分配)当然也无法实现良好的稳定性和安全性。
4. 在Linux中，系统调用是除了中断和异常之外，内核唯一的合法入口。

## Makefile 编写
`Makefile`描述了整个工程的编译、连接规则，利用`make`工具可以完成自动编译工作，这些工作包括：
1. 如果修改了几个源文件，则只编译这几个源文件
2. 如果修改了头文件，则编译所有包含该头文件的源文件   
(即只编译有改动的源文件)

* 基本规则
```Makefile
target:xxx
dependance:xxx
command:xxx
```
* 编写一个clean命令的makefile文件
```Makefile
.PHONY:clean                                          # .PHONY声明clean为伪目标
main:main.o sub.o add.o print.o                       # 依赖关系
    gcc -Wall -g main.o sub.o add.o print.o -o main   # 编译命令
main.o:main.c
    gcc -Wall -g main.c -o main.o
add.o:
    gcc -Wall -g add.c -o add.o
sub.o:
    gcc -Wall -g sub.c -o sub.o
print.o:
    gcc -Wall -g print.c -o print.o
clean:rm -f *.o main                                  # 删除编译中间文件
```
* 自动化变量

选项名|作用
--|--
$@|目标文件名
$<|第一个依赖文件名
$^|所有依赖文件列表
$ 取值，类似于 *pointer.
```Makefile
Makefile
.PHONY:clean
OBJ = main.o sub.o add.o print.o                                
main:$(OBj)                    
    gcc -Wall -g $^ -o $@ 
main.o:main.c
    gcc -Wall -g $< -o $@
add.o:add.c
    gcc -Wall -g $< -o $@
sub.o:sub.c
    gcc -Wall -g $< -o $@
print.o:print.c
    gcc -Wall -g $< -o $@
clean:rm -f *.o main
```
* 简化
```Makefile
.PHONY:clean

CC = gcc
CFLAGS = -Wall -g
OBJ = main.o sub.o add.o print.o   
main:$(OBJ)
    $(CC) $(CFLAGS) $^ -o $@
.c:.o
    $(CC) $(CFLAGS) -c $< -o $@

clean:
    rm -f *.o main
```
## GDB 相关
* 编译时加入调试信息 (关键第一步，开启调试大门)
```bash
gcc test.c -g   # -g 开启调试
```
* 设置断点
```bash
b 4      # 在第4行设断点
b main   # 在main设断点 
b function_name  # 查看子函数
```
* 查看
```bash
# 查看参数
p param
# 查看指针申请的数组
p *array@len

```
* 运行    
```bash
# 运行时输入参数
r hello
```
* 显示所有的断点信息 
```bash
info break
```
* 删除断点
```bash
delete num    # 断点号
```
* 进入函数内部，单步调试
```bash
step
```
* 显示相关信息
```bash
list __FILE__ , __LINE__ , __DATE__ , __TIME__ 
```
* 查看程序的运行栈
```bash
bt
```
* 退出     `q(quit)`
* 继续执行 `c(continue)` 
* 重启调试 `restart`

## 如何定位内存泄露
内存泄露是指堆内存的泄露。因为堆是有程序员通过malloc，new，realloc自由分配的内存块。
### Linux 检测内存泄露
```bash
ps -aux     # 监视内存的使用，列出所有正在运行的进程及其PID
kill        # 杀死进程，回收内存
top         # 查看进程的动态内存总额
```
* mtrace
```C
#include <stdio.h>
  
int main()  
{       // 生成日志文件 test.log
        setenv("MALLOC_TRACE", "test.log", "1");  
        mtrace();   //紧盯每一组malloc/free

        // 明显没有释放内存
        int *p = (int *)malloc(2 * sizeof(int));  
  
        return 0;  
}  
```
编译文件，运行，检测
```bash
gcc test.c -g 
./a.out
mtrace a.out test.log
``` 
### 静态分析(文本检测)
* 人工检测
* 静态代码分析工具

`BEAM`可以检测四类问题: 未初始化的变量；废弃的空指针；内存泄漏；冗余计算
### 动态检测(运行阶段)
主要有`valgrind`.程序通过 valgrind 运行时，valgrind 收集各种有用的信息，通过这些信息可以找到程序中潜在的 bug 和性能瓶颈。

Valgrind 现在提供多个工具，其中最重要的是 `Memcheck，Cachegrind，Massif 和 Callgrind`
## 动态链接和静态链接的区别
二者都是通过`共享内存`实现的。  
* 区别

**lib**:静态链接的库函数，编译结束后会lib库文件会包含在可执行文件中，所以最后得到的文件更占内存。
**dll**:动态连接的库函数，编译结束后会自动卸载这部分指令。节省内存，dll库与a.out相互独立，更改dll一般不影响a.out.

* 静态链接

所谓静态链接是指把要调用的函数或者过程链接到可执行文件中，成为可执行文件的一部分。换句话说，函数和过程的代码就在程序的exe文件中，该文件包含了运行时所需的全部代码。当多个程序都调用相同函数时，内存中就会存在这个函数的多个拷贝，这样就浪费了宝贵的内存资源。

* 动态链接

动态链接所调用的函数代码并没有被拷贝到应用程序的可执行文件中去，而是仅仅在其中加入了所调用函数的描述信息（往往是一些重定位信息）。仅当应用程序被装入内存开始运行时，在Windows的管理下，才在应用程序与相应的DLL之间建立链接关系。当要执行所调用DLL中的函数时，根据链接产生的重定位信息，Windows才转去执行DLL中相应的函数代码。

## 32位系统一个进程最多多少堆内存
32位宽指的是`数据总线宽度`，而不是寻址范围。Windows对于内存的管理，采取的是`分页机制`。目前的32位系统`分页大小为4K`，`寻址位宽为32位`，因此，第0个分页的地址是0x00000000，第1个分页地址从0x00001000开始，以此类推。所以，在目前的32位系统中，用到了32位中的高20位来标记物理页，剩余的12位用于添加一些标记信息等。这样，就可以支持到最大(2^20)*4096=4GB内存 

## 如何实现守护进程Daemon？
`守护进程`（Daemon）是运行在后台的一种特殊进程，独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。

在Linux中，每一个从终端开始运行的进程都会依附于这个终端，这个终端被称为这些进程的控制终端，当控制终端被关闭的时候，相应的进程都会自动关闭。而Daemon能打破这种限制，`脱离终端独立`于后台运行。

脱离终端的`目的`是为了避免进程在运行的过程中进程信息在任何终端泄露或者被终端信息打断，直到整个系统关闭，Daemon才退出。
* 特性
1. 后台运行
2. 独立性，与其运行前的环境隔离开。
3. 启动方式特殊，从启动脚本/etc/rc.d中启动，可以由作业规划进程crond启动，还可以由用户终端（shell）执行。
* 实现Daemon的步骤

![](http://www.xitongzhijia.net/uploads/allimg/171023/56-1G023143343-water.jpg)
![]()

1. 调用`umask`将文件权限掩码设置为0(即不屏蔽任何权限)。文件权限掩码：是指屏蔽掉文件权限中的对应位。`umask(0)`
2. fork得到子进程，exit退出父进程.`if (pid==fork()) exit(0)` 
3. 调用`setsid`以创建一个`新会话`，作用是使进程脱离原控制终端、原进程组、原会话。

![](http://www.th7.cn/d/file/p/2017/12/29/70dff4fc8855ed2c56bd3ea7da0e4890.jpg)

4. `chdir("/")`将当前工作目录更改为根目录 
```C
#define NOFILE 256
for (int i=0; i<NOFILE; i++) 
    ++i;
```
5. 关闭不再需要的文件描述符，因为守护进程不再持有从父进程继承的文件描述符。
6. 某些守护进程会打开`/dev/null`添加文件描述符0、1和2，这样，任何一个试图读标准输入、写标准输出和标准出错的库例程都不会产生任何效果。因为守护进程并不与终端设备相关联，所以不能在终端设备上显示其输出，也无处从交互式用户那里接受输入。
* fork返回值
fork()调用一次，有两个返回值:0(传给子进程)、子进程id(传给父进程)，因为父进程需要知道子进程的id
```C
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <syslog.h>

void daemonize(const char *cmd)  
{  
    int i, fd0, fd1, fd2;  
    pid_t  pid;  
    struct rlimit       rl;  
    struct sigaction    sa;  

    // ===== 1 =====
    umask(0);

    // ===== 2 =====
    if (getrlimit(RLIMIT_NOFILE, &rl) < 0)  {       // 最大的文件描述符数目
        err_quit("%s: can't get file limit", cmd);  
    }  
    if ((pid=fork()) < 0)                           // 保证fork的不是进程组组长
        err_quit("%s can not fork", cmd);
    if ((pid=fork()) != 0)                          // 父进程
        exit(0); 

    // ===== 3 =====
    setpid();  // 创建一个会话，会话只包含子进程，且子进程是会话首进程 
    /* 
     * 首进程退出时，会话终止，所以要确保Daemon不是首进程
     * 会话首进程的退出会出发SIGHUP信号 
     */ 
    sa.sa_handler = SIG_IGN;  
    sigemptyset(&sa.sa_mask);  
    sa.sa_flags = 0;  
    if (sigaction(SIGHUP, &sa, NULL) < 0)  {  
        err_quit("%s: can't ignore SIGHUP", cmd);  
    }  

    // 再次创建子进程，退出父进程，保证守护进程不是会话首进程，这样open的时候就不会被分配终端 
    if ((pid=fork()) < 0)                           // 保证fork的不是进程组组长
        err_quit("%s can not fork", cmd);
    if ((pid=fork()) != 0)                          // 父进程
        exit(0); 

    // ===== 4 =====
    if (chdir("/") < 0)   {  
        err_quit("%s: can't change directory to /", cmd);  
    }  

    // ===== 5 =====
    f (rl.rlim_max == RLIM_INFINITY)   {  
        rl.rlim_max = 1024;  
    }  
    for (i = 0; i < rl.rlim_max; i++)    {  
        close(i);  
    }  

    // ===== 6 =====
    /* 
     * 因为前面关闭了所有的文件描述符，此时open返回的必定是最小的0，后面两次dup()返回的依次是1、2，
     * 即完成了对标准输入、标准输出、标准错误重定向至/dev/null的操作，与终端分离
     */  
    fd0 = open("/dev/null", O_RDWR);  
    fd1 = dup(0);  
    fd2 = dup(0);  

    // 初始化日志
    openlog(cmd, LOG_CON, LOG_DAEMON);
    if (fd0 != 0 || fd1 != 1 || fd2 != 2) {
        syslog(LOGERR, "unexpected file descriptor %d %d %d", fd0, fd1, fd2);
        exit(1);
    }
```
* 两次fork是为了确保守护进程不是会话首进程。
## Linux内存管理机制

[浅谈内存管理机制](https://blog.linuxeye.cn/362.html)

Linux内存管理会利用空闲的物理内存划分出一部分空间，作为cache(页高速缓存)、buffers，将磁盘中的数据读入内存(作为磁盘高速缓存)，提高了物理内存利用率，也提高了访问效率(因为访问内存的速度远大于访问磁盘)。而windows空闲物理内存没有利用起来，相当于摆式。
* Cache、buffer

**cache**:高速缓存，是位于CPU与磁盘间的一种容量较小但速度很高的存储器，存储磁盘中的数据。通常作为文件缓冲，存放文件具体内容。

**buffer**:缓冲区，用于存储`速度不同步`或`优先级不同`的设备之间`传输数据`的区域。通过缓冲区，可以使进程之间的相互等待变少，从而使从速度慢的设备读入数据时，速度快的设备的操作进程不发生间断。通常作为块设备缓冲，记录文件系统元数据，即文件目录，文件属性等

* Linux内存管理机制
1. 虚拟内存

直接从内存读取数据比从磁盘(disk)读取数据要快很多，所以会希望把所有的数据都写入内存，但是`物理内存是有限的`，所以有了虚拟内存.

物理内存就是系统硬件提供的内存大小，是真正的内存;虚拟内存是为了满足物理内存的不足而提出的策略，是利用`磁盘空间虚拟`出的一块`逻辑内存`，用作虚拟内存的磁盘空间被称为`交换空间(Swap Space)`。

`交换空间`用于暂时存放内存中暂时用不到的信息，释放了部分内存，这样这些内存就可以用于其他地方，当这些信息需要用到时，重新写入内存。

![](https://images2018.cnblogs.com/blog/1416789/201808/1416789-20180805143503098-898825651.png)
允许随着动态内存分配，堆向上生长；允许随着子程序的不断调用，栈向下生长。

[虚拟内存管理](https://www.codetd.com/article/2563426)

2. 分页存取机制

为了保证物理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。

## Linux任务调度机制
任务调度（schedulers）是内核的主要职责，实际上它就是一个法官，决定当前由哪个任务占用CPU，多数实时内核都是`基于优先级调度算法` 的，每个任务根据其重要程度的不同被赋予一定的优先级。基于此算法，CPU总是让处于就绪而且优先级最高的任务优先运行，然而何时高优先级任务能够得到 CPU使用权，由`内核的类型`而定。基于优先级的内核有两种：`不可抢占型、可抢占型`
### 不可抢占型
要求每个任务主动放弃CPU使用权，即高优先级的任务不能抢占CPU，只有当前执行的任务主动让出CPU时才能占用。
* 优点

1. 不需要在中断、返回间切换，所以中断响应快
2. 任务执行过程中调用不可重入函数，故不必担心数据破坏或者丢失
3. 数据独享，不需要调用信号量来保护数据

* 缺点

响应时间不确定，故一般用于前后台系统。

### 可抢占型
通过给每个进程设置一个`优先级`，当系统中有优先级比当前运行的进程的优先级更高的进程时，当前的进程执行被中断，并`调用调度程序`选择优先级高的进程运行。利用抢占式内核，可以保证高优先级的进程被优先执行，从而保证系统的`实时响应`。一般用于嵌入式系统。

### 任务调度
即任务顺序切换，使用系统函数。发生在内核态(系统调用或中断)进入用户态时。
1. 进程本身直接调用任务切换函数`schedule()`
2. 延迟调用任务切换函数进行调度(在当前进程设置一调度标志TIF_NEED_RESCHED)

### 调度算法
3种调度算法

实时进程|普通进程(分时调度)
--|--
SCHED_FIFO、SCHED_RR|SCHED_NORMAL

## 系统如何将一个信号signal通知到进程
在进程所在的`进程表项sigset_t`的`信号域`设置对应信号的位值. `frame`是进程在用户态和内核态之间跳转时，对堆栈现场的压栈保存
* 假定进程A、进程B，A发送信号给B，B接受信号并调用信号处理函数，过程如下：
1. A调用信号发送函数`发送signal`
2. 内核(中间人)接收到信号，先检查一下A是否有权限修改B进程表项信号域的对应位，若可以，则`修改B进程的信号域`
3. 内核完成修改，发送中断请求给B，B进入`内核态`
4. B根据信号表，查找对应的此信号的处理函数，设置frame，返回用户态执行信号处理程序，此时B进程挂起
5. 处理结束，返回内核态再设置一次frame，然后回到用户态，从中断位置开始继续执行原进程

## 宏替换
* # / ##
```C
#include <stdio.h>
#define f(a,b) a##b    // 拼接两个宏参数
#define g(a)  #a       // 把宏参数转化为字符串
#define h(a)  g(a)
 
int main()
{
        printf("%s\n", h(f(1,2)));    // h(f(1,2)) == h(12) = 12
        printf("%s\n", g(f(1,2)));    // g、f都有宏替换，所以f(1,2)不能展开，g(f(1,2)) == f(1,2)
        return 0;
}
```
* 宏展开
1. 注释//... /*...*/ 替换成空格
2. 预处理命令，如#include / #define / #error / #pragma...
3. 转义字符转换等


